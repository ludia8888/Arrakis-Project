OMS 온톨로지 타입 ∙ 그래프 기능 USE CASE & 요구사항 명세서

⸻

0. 문서 범위 & 목표
	•	대상 시스템 : Ontology Metadata Service (OMS)
	•	목표 : Object Type·Property·Shared Property·Link Type·Action Type·Interface·Data Type·Semantic Type·Struct Type 및 ‘그래프 기능’ 4종을 100 % 일치하게 구현·운영하기 위한 사용자 시나리오(Use Case) 와 세부 요구사항 제시

⸻

1. 이해관계자

ID	이해관계자	관심사
STK-ADMIN	스키마 관리자	모든 온톨로지 타입 정의·버전 관리
STK-DEV	애플리케이션 개발자	API / SDK로 타입·그래프 이용
STK-ANL	데이터 애널리스트	객체·링크 기반 분석·탐색
STK-USR	최종 업무 사용자	액션으로 데이터 변경·프로세스 실행


⸻

2. 주요 Use Case

모든 흐름에 “객체 타입-속성-링크-액션” 정의가 선행되어야 하며, CRUD 작업은 OMS API 로만 수행한다.

UC-01 : 객체 타입 생성

항목	내용
목적	현실 세계 개념을 Object Type으로 등록
행위자	STK-ADMIN
전제	데이터 모델링 지침 승인 완료
기본 흐름	1) Object Type 이름·설명 입력 → 2) Property(없으면 빈 상태) 포함 → 3) 저장
성공 조건	새로운 Object Type 메타엔트리 생성, 버전 = 1

UC-02 : 속성 추가

항목	내용
목적	Object Type에 구체적 Property 부여
행위자	STK-ADMIN
전제	UC-01 완료
기본 흐름	1) 목록에서 대상 Object Type 선택 → 2) Property 이름·데이터 타입(필드 / 베이스) 지정 → 3) 제약·표현 형식(필요 시 Semantic Type·Struct Type)을 연결 → 4) 저장
성공 조건	해당 Object Type 속성 스키마가 갱신·버전+1

UC-03 : 공유 속성 정의·재사용

항목	내용
목적	여러 Object Type에 동일한 속성(Shared Property)을 일관 적용
행위자	STK-ADMIN
기본 흐름	1) Shared Property 등록(이름·데이터/시맨틱 타입·검증 로직) → 2) 적용 대상 Object Type들 선택 → 3) 저장
성공 조건	선택된 모든 Object Type에 동일 Property reference 추가, 중앙 변경 시 즉시 반영

UC-04 : 링크 타입 설정

항목	내용
목적	두 Object Type 사이 관계(Link Type) 스키마화
행위자	STK-ADMIN
기본 흐름	1) 출발·도착 Object Type 지정 → 2) Cardinality·방향성·FK 필드 선택 → 3) 권한·상태 전파 옵션 지정 → 4) 저장
성공 조건	Link Type 메타엔트리 생성, 탐색 메타 Manifest 생성 ->OMS는 메타데이터만 기록. 실제 인덱스 구축·탐색은 Object Set Service 책임(OUT OF SCOPE)



UC-05 : 액션 타입 실행

항목	내용
목적	업무 이벤트를 데이터 변경으로 반영(Action Type)
행위자	STK-USR
전제	UC-01~04로 객체 모델 완비, Action Type 사전 등록
기본 흐름	1) 객체 인스턴스 선택 → 2) 실행 가능한 Action Type 목록 조회 → 3) 파라미터 입력(필요 시) → 4) 실행 → 5) OMS → Action-Service에 트랜잭션 요청
성공 조건	지정된 속성·링크 값 일괄 변경, 변경 이력 기록, 승인 워크플로(필요 시) 트리거


⸻

3. 기능 요구사항 (Functional Requirements)

ID	요구사항	매핑 타입
FR-OT-CRUD	OMS는 Object Type을 Create/Read/Update/Delete 할 수 있어야 한다.	Object Type
FR-PR-META	각 Property는 데이터 타입, 제약, 포맷을 메타데이터로 보유해야 한다.	Property
FR-SH-REUSE	Shared Property는 단 1회 정의 후 N개의 Object Type에서 참조·재사용된다.	Shared Property
FR-LK-DEF	OMS는 방향성·Cardinality를 포함하는 Link Type 정의 기능을 제공한다.	Link Type
FR-LK-IDX	Link Type 저장 시 출발→도착 키를 메타 Manifest 로 산출·저장한다.	그래프기능①②
FR-AC-TRX	Action Type은 다중 객체/속성/링크 변경을 단일 트랜잭션으로 실행한다.	Action Type
FR-IF-POLY	Interface 정의 시 이를 구현한 모든 Object Type이 공통 속성·액션을 상속한다.	Interface
FR-DT-CONST	Data Type은 정해진 필드 타입·베이스 타입 목록만 허용한다.	Data Type
FR-SM-VALID	Semantic Type은 값 패턴·제약을 검증하여 잘못된 입력을 차단한다.	Semantic Type
FR-ST-STRUCT	Struct Type은 다중 하위 필드를 가진 복합 속성을 정의·조회할 수 있다.	Struct Type
FR-GR-PERM	Link Type에 설정된 권한·상태 전파 규칙이 액션·워크플로에 전달되어야 한다.	그래프기능③


⸻

4. 비-기능 요구사항 (Non-Functional)

ID	요구사항
NFR-SEC-1	속성·링크·액션 호출은 역할 기반 권한 시스템(ROW-LEVEL & FIELD-LEVEL)을 따른다.
NFR-AUD-1	모든 타입·그래프 메타데이터 변경은 불변 감사 로그를 남긴다.
NFR-SCAL-1	 \n– Object Type ≤ 100 k
NFR-INT-1	OMS SDK는 Java, Python, TypeScript 3종을 공식 지원한다.


⸻

5. 그래프 기능 상세 요구

기능 ID	세부 명세	반드시 충족할 이유
GF-01	링크 타입 정의: Cardinality, 방향성, FK 매핑 필수	객체 간 조인·계층 집계의 기초
GF-02	그래프 인덱스 & 탐색 메타: “src-dst 키 메타 값 계산, transitiveClosure flag 기록
	대화식 그래프 탐색 UI의 실시간 응답
GF-03	권한·상태 전파 규칙: permissionInheritance, statePropagation flag	상위-하위 객체 승인·잠금 일괄 반영
GF-04	API 스키마 출력: 링크 기반 GraphQL 필드 및 REST 리소스 자동 노출	FE/서버리스에서 즉시 관계 데이터 활용->실제 Resolver는 Object Set Service가 구현->OUT OF SCOPE


⸻

6. 데이터 사전 (요약)

카테고리	표준 약어	설명
OT	Object Type	현실 개체·사건 스키마
PR	Property	OT 속성
SP	Shared Property	여러 OT 공통 속성
LT	Link Type	두 OT 관계
AT	Action Type	다중 변경 트랜잭션
IF	Interface	OT 추상 구조
DT	Data Type	필드·베이스 타입
ST	Semantic Type	값 타입(제약 포함)
SCT	Struct Type	복합 속성

---
| **타입** | **정의** | **예시** | **사용 목적** | **시스템 내 역할** |
| --- | --- | --- | --- | --- |
| **Object Type (객체 타입)** | 현실 세계의 **개체(entity)나 사건(event)**를 표현하는 온톨로지 스키마로, 하나의 객체 타입은 여러 **객체 인스턴스**로 구성됩니다 . 예를 들어 Airport라는 객체 타입이 있다면 JFK와 LHR은 해당 객체 타입의 개별 객체 인스턴스입니다 . | *예시:* “고객”, “주문”, “설비”와 같은 객체 타입을 정의하고, 각각 실제 데이터를 나타내는 객체 인스턴스(예: 고객 객체 ‘홍길동’, 주문 객체 ‘ORD123’)를 가집니다  . | 여러 데이터 소스를 **현실 세계 개념**에 매핑하여 통합된 스키마를 제공하고, 도메인의 공통 언어를 형성합니다 . 이를 통해 데이터셋들을 객체 중심으로 정규화하고, 후속 분석이나 애플리케이션 개발 시 일관성 있게 활용할 수 있습니다. | 온톨로지의 **핵심 의미론 요소**로서, 조직의 디지털 트윈을 구성합니다 . 객체 중심의 탐색(Object Explorer), 검색, 권한 관리 등이 이 타입을 기반으로 이루어지며, 워크샵 등 사용자 애플리케이션에서 객체 단위로 데이터가 표시되고 분석됩니다  . |
| **Property (속성)** | 객체 타입이 가지는 **특성(attribute)**을 나타내며, 현실 세계 개체의 속성값을 표현합니다. 예를 들어 Airport 객체 타입의 속성으로 name이나 country가 있을 수 있고, LHR 객체의 해당 속성값은 “London Heathrow” (name), “United Kingdom” (country) 등이 됩니다 . | *예시:* Customer 객체 타입은 이름, 이메일 등의 속성을, Order 객체 타입은 주문일자, 금액 등의 속성을 가질 수 있습니다. 각 속성은 해당 객체의 한 가지 데이터를 의미합니다. | 객체에 **구체적인 데이터 값**을 부여하여 현실 세계 개체의 특징을 표현합니다. 데이터를 개별 속성으로 분리함으로써 데이터 품질 검증, 형식 지정, 검색 최적화 등 세밀한 관리가 가능합니다. 또한 속성 메타데이터(유형, 제약 조건 등)를 풍부하게 정의하여 데이터에 맥락을 부여합니다 . | **온톨로지 스키마의 필드들**로서, 객체의 데이터를 담고 애플리케이션에 노출합니다. 속성별로 **데이터 타입**과 **값 타입**이 지정되어 Foundry 전반에서 해당 값에 대한 유효 연산을 결정하며  , Quiver 같은 분석 도구나 검색 인덱싱 등에 활용됩니다. 또한 권한 및 거버넌스 적용 시 속성 단위로 관리되어 민감 정보 통제 등에 기여합니다. |
| **Shared Property (공유 속성)** | 여러 객체 타입에서 **공통적으로 활용**할 수 있도록 중앙 정의된 속성 타입입니다. 한 번 정의하여 여러 객체에 적용할 수 있으므로, 예컨대 여러 개의 객체 타입이 모두 email 속성을 필요로 할 때 단일 공유 속성을 만들어 일관성 있게 쓸 수 있습니다 . | *예시:* Email 주소 공유 속성을 정의해 두면 고객, 직원, 파트너 등 여러 객체 타입에 공통으로 이 속성을 추가하여 모두 형식 검증(이메일 패턴 등)과 표현을 동일하게 가져갈 수 있습니다. | **중복되는 속성 정의를 재사용**하여 모델링의 일관성을 유지하고 관리 효율을 높입니다. 공유 속성을 수정하면 이를 사용하는 모든 객체 타입에 자동 반영되므로, 속성 메타데이터(표현 형식, 검증 로직 등)를 중앙에서 일괄 관리할 수 있습니다 . | 온톨로지 전반의 **표준화된 데이터 사전** 역할을 합니다. 조직 전역에서 공통으로 쓰이는 속성(예: 식별자, 이름, 이메일 등)에 대해 통합 스키마를 제공하여, 데이터 통합과 거버넌스를 용이하게 하고 속성 간 매핑이나 연계 분석 시 **호환성**을 보장합니다. |
| **Link Type (링크 타입)** | 두 객체 타입 간의 **관계(relation)**를 정의하는 온톨로지 스키마입니다. 하나의 링크 타입은 특정 객체 타입 A와 객체 타입 B 사이의 관계를 나타내며, 실제 **링크(link)**는 두 객체 인스턴스 사이에 맺어지는 한 건의 관계(엣지)에 해당합니다 . | *예시:* Employee 객체와 Company 객체 사이에 고용 관계 링크 타입을 정의하면, 개별 직원 객체와 회사 객체 사이의 한 건의 링크가 “입사” 관계를 나타냅니다  . 또 다른 예로 Order와 Product 사이에 다대다 관계의 주문-상품 포함 링크 타입을 만들어, 특정 주문 객체와 제품 객체들을 연결하는 여러 링크 인스턴스를 가질 수 있습니다 . | **객체들 간의 연결**을 모델링하여 데이터 간 관계와 종속성을 표현합니다. 이를 통해 조직의 데이터 모델에 존재하는 계층 구조(부서-직원 등), 일대다/다대다 관계(주문-상품 등), 네트워크 그래프 구조(소셜 네트워크 등)를 Ontology 차원에서 명시적으로 관리합니다. | 온톨로지의 **그래프 구조**를 형성하는 요소로서, 객체 간 연관 탐색, 인접 객체 검색, 그래프 분석을 가능하게 합니다. Foundry에서는 링크 타입 정의가 데이터셋 간 **조인(join)** 관계와 유사한 역할을 하여, 예를 들어 두 데이터셋을 조인한 결과가 곧 두 객체의 링크에 대응됩니다 . 링크를 통해 Object Explorer 등의 UI에서 관련 객체를 조회하거나, 링크 자체를 객체처럼 다루는 (예: many-to-many 관계의 링크 객체화) 활용이 가능합니다 . |
| **Action Type (액션 타입)** *(Transformation Type)* | 하나 이상의 객체, 속성, 링크에 대한 일련의 **변경 작업**을 정의한 스키마입니다. 액션 타입은 사용자가 **동시에 수행할 수 있는 변경들의 모음**(예: 여러 필드값 수정 + 링크 생성/삭제 등)을 정의하고, 액션 실행 시 발생하는 사이드이펙트(후속 동작)까지 포함합니다 . 온톨로지에 액션 타입이 등록되면 최종 사용자들은 해당 액션을 실행하여 객체 데이터를 변경할 수 있습니다. | *예시:* “주문 승인”이라는 액션 타입을 만들어, 실행 시 Order 객체의 상태 속성을 “승인됨”으로 변경하고 승인 시간 속성을 기록하며, 관련 담당자에게 알림을 보내는 사이드이펙트를 포함하도록 할 수 있습니다. 사용자는 특정 주문 객체에 이 액션을 적용하여 시스템 내에서 **트랜잭션성 변경**을 가할 수 있습니다. | 현업 사용자가 **업무 이벤트**를 시스템에 반영할 수 있도록 하는 도구입니다. 객체 데이터를 수동으로 변경하는 대신 사전 정의된 액션을 통해 **절차화된 변경**만 이루어지게 하여, 데이터 무결성과 비즈니스 규칙을 준수하는 동시에 사용자 편의를 제공합니다. | 온톨로지의 **동적 요소(kinetic element)**로서 작동하여, 조직 운영상의 프로세스를 플랫폼에 이식합니다 . 액션 타입을 통해 Foundry는 단순 조회나 분석뿐만 아니라 **운영상의 변경**까지 가능해지며, 변경 이력 추적, 승인 워크플로 등 **거버넌스** 체계를 적용할 수 있습니다. 또한 액션은 함수(Functions)와 연계되어 복잡한 비즈니스 로직을 실행하거나 외부 시스템과 연동하는 트리거로 활용되어, **데이터 변환 및 프로세스 오케스트레이션**에 기여합니다. |
| **Interface (인터페이스)** | 여러 객체 타입에 공통되는 **속성 구조와 동작**을 정의한 추상적인 온톨로지 타입입니다. 하나의 인터페이스는 특정 속성들의 집합과 지원 기능(액션 등)을 기술하여, 이를 구현(implement)하는 객체 타입들이 해당 구조와 기능을 공통적으로 갖게 합니다 . | *예시:* 장비 인터페이스를 정의해 식별자, 설치일 등의 공통 속성을 포함시키고 “점검하기” 액션을 연결하면, 이를 구현하는 펌프, 모터 등 여러 장비 관련 객체 타입은 모두 동일한 속성과 액션을 가지게 됩니다. 이렇게 하면 각기 다른 장비 객체들을 하나의 형식으로 취급할 수 있습니다. | **객체 타입의 다형성(polymorphism)**을 제공하여, 공통된 속성과 행위를 묶어 관리합니다. 인터페이스를 통해 중복 정의를 줄이고, 객체 타입 간에 일관된 상호작용 패턴을 만들 수 있습니다. 개발자는 인터페이스에 의존하는 기능을 작성하여, 해당 인터페이스를 구현한 다양한 객체 타입에 재사용할 수 있습니다. | 온톨로지 내 **추상 계층**을 형성하여, 객체 모델의 유연성과 확장성을 높입니다. 인터페이스를 활용하면 Foundry 애플리케이션 (예: 워크샵 앱, 액션 설정 등)에서 다양한 객체 타입을 **한 개의 타입처럼 처리**할 수 있어, 공통 뷰 구성이나 통합 액션 적용이 가능합니다. 또한 인터페이스별로 권한이나 거버넌스 규칙을 부여하여 객체 타입군에 대한 일괄적인 통제를 실현할 수도 있습니다. |
| **Data Type (데이터 타입)** *(Field/Base Type)* | **데이터 값의 형식**을 정의하는 타입으로, 주로 속성에 허용되는 값의 종류를 결정합니다. Foundry의 데이터 타입은 RDF/OWL 등의 표준을 참고하여 정의된 원시 **필드 타입(field type)**들과, 이를 객체 속성용으로 확장한 **베이스 타입(base type)**들로 구성되어 있습니다  . 필드 타입은 Boolean, String, Integer, Long, Array 등 프로그래밍 언어의 기본형과 유사한 타입들을 포함하며, 베이스 타입은 여기에 **추가 연산/제약 정보**를 담아 속성에 사용됩니다  . | *예시:* 필드 타입으로 String은 문자열, Integer는 정수형 데이터를 나타냅니다. 베이스 타입의 예로 Geopoint는 경도/위도 좌표 쌍을 표현하고, Vector는 임베딩 등 벡터 값을, Time series는 시계열 데이터를 나타내는 타입입니다 . 이러한 타입으로 각 속성의 데이터 형식을 지정합니다. | 각 속성에 저장될 데이터의 **형식과 연산 가능 범위**를 결정하여 **타입 안전성**을 제공합니다 . 예를 들어 숫자형 데이터 타입은 합계 등의 수치 연산을 지원하고, 날짜 타입은 시간 연산과 특수 포맷 처리가 가능합니다. 또한 데이터 타입별로 Foundry 애플리케이션에서 **렌더링 방식**이나 **필터 옵션** 등이 자동 적용되어, 사용자 경험이 데이터에 맞게 최적화됩니다. | Foundry 플랫폼 전반에서 **일관된 데이터 형식 체계**를 이루어, 파이프라인이나 분석 시 **스키마 정합성**을 유지시킵니다. 온톨로지에서는 지원 필드 타입 목록이 정해져 있어 새로운 원시 타입을 임의로 추가할 수는 없지만, 이 통제된 타입 시스템을 통해 데이터 파이프라인, 모델, Ontology 간에 **공통 기준**이 형성됩니다  . 또한 각 데이터 타입은 Object Explorer 등의 검색 인덱싱이나 쿼리 최적화 시 적절한 처리(예: 텍스트 vs 숫자)를 보장합니다. |
| **Semantic Type (시맨틱 타입)** *(Value Type)* | **값 타입(Value Type)**이라고도 하며, 기본 데이터 타입(필드 타입)에 **의미론적 메타데이터와 제약**을 부가한 래퍼(wrapper) 타입입니다 . 예를 들어 정수형 필드에 “제품 ID”라는 의미를 부여하거나, 문자열 필드에 “이메일 주소” 의미와 형식(정규식) 제약을 줄 수 있습니다. 이러한 값 타입은 특정 **스페이스(작업 공간)** 내에서 정의·사용되며, 사용자 도메인에 맞는 커스텀 타입을 만들 수 있습니다  . | *예시:* “EmailAddress”라는 값 타입을 만들어 이메일 형식 유효성 검사를 포함시킬 수 있습니다 . 이후 어떤 객체 타입의 속성이든 이를 값 타입을 EmailAddress로 지정하면, 시스템은 해당 속성값이 항상 이메일 패턴과 일치하는지 검증합니다. 마찬가지로 “URL”, “전화번호”, “제품카테고리(열거형)” 등 도메인별 값 타입들을 정의해 활용할 수 있습니다 . | **도메인 맥락과 제약 조건**을 데이터 속성에 부여함으로써, 데이터의 의미를 명확히 하고 **잘못된 데이터 입력을 방지**합니다 . 개발자는 값 타입을 한 번 정의해 두고 여러 파이프라인이나 객체 속성에 적용함으로써, 반복적으로 검증 로직을 구현할 필요 없이 **일관된 데이터 품질**을 확보합니다 . 또한 값 타입명 자체가 해당 데이터의 의미를 표현하므로, 협업 시 컬럼명/설명에 의존하지 않고도 데이터 해석이 쉬워집니다. | Foundry 플랫폼에서 **재사용 가능한 데이터 스키마 구성 요소**로 작동합니다. 값 타입을 사용하여 Builder 파이프라인 단계에서 입력 데이터의 유효성을 자동 검증할 수 있고, 잘못된 데이터는 애초에 Ontology에 통합되지 않도록 차단할 수 있습니다  . 또한 Ontology를 활용한 애플리케이션(예: 폼 입력 시 이메일 필드 자동 검증)에 값 타입이 반영되어 **사용자 경험과 데이터 신뢰성**을 높입니다. |
| **Struct Type (구조체 타입)** | **다중 필드**로 구성된 복합 속성을 정의하기 위한 특수 타입입니다. 하나의 Struct는 여러 하위 필드를 가지는 **스키마 기반 속성**으로, 예를 들어 하나의 “주소” 속성 안에 거리, 도시, 우편번호, 국가와 같은 여러 필드를 포함할 수 있습니다  . Struct 타입의 속성은 해당 구조에 맞는 **Struct 컬럼**(예: Spark의 Struct 타입 컬럼)으로부터 데이터를 받아 객체에 정의됩니다 . | *예시:* Full Name 구조체 속성을 정의하여 First Name과 Last Name 두 하위 문자열 필드를 가지도록 할 수 있습니다 . 이렇게 하면 Full Name이 하나의 속성이지만 이름과 성을 개별 필드로 취급할 수 있고, UI에서도 전체 이름을 하나로 표시하면서도 필요시 필드를 분리해 활용할 수 있습니다. 또 다른 예로 앞서 언급한 Address Struct 속성에는 여러 주소 구성요소 필드가 포함됩니다 . | 서로 연관된 여러 필드를 **논리적으로 한 묶음**으로 다루어 데이터 모델을 깔끔하게 유지하고자 할 때 사용합니다. 구조체 타입을 통해 주소, 성명 등 일반적으로 함께 다뤄지는 필드 모음을 단일 속성처럼 취급하면 객체 타입의 속성 목록을 단순화하고 관리 부담을 줄입니다. 또한 구조체 내부 필드마다 적절한 데이터 타입을 지정할 수 있어 세부 데이터까지 타입 안전성을 유지합니다. | 온톨로지에서 **복합 데이터 타입 지원**을 구현한 것으로, 현재 Foundry의 여러 기능에서 제한적으로 지원되고 있습니다  . Struct 속성은 Ontology Manager와 Pipeline Builder에서 생성·편집할 수 있고, 워크샵 등에서 표시 및 변수로 활용 가능합니다 . 다만 중첩 Struct 등은 미지원이며, Functions이나 Actions에서의 사용도 제한이 있어  점진적으로 플랫폼 내 지원 범위가 확대되고 있습니다. Struct 타입의 도입으로 Foundry가 **반정형 데이터** 구조를 다룰 수 있게 되어, 복잡한 데이터 통합 시 유연성이 향상됩니다. |

## 그래프 기능

| **그래프 기능** | **OMS 수준에서 구체적으로 해야 할 일** | **왜 필요한가** |
| --- | --- | --- |
| **① 링크 타입(Link Type) 정의** | • 두 Object Type 사이의 *스키마적 관계*를 linkType 메타엔트리로 등록• Cardinality (1-1, 1-N, N-N)·방향성·FK 매핑 보유 | • 객체 간 네비게이션·조인·상위 / 하위 집계의 기초가 됨 |
| **② 그래프 인덱스 & 탐색 메타정보** | • 각 링크의 “출발-도착” 인덱스 키를 계산(예: srcId→dstId)• Cascade depth, transitive closure 허용 여부 등 탐색 힌트 보관 | • Vertex 같은 UI에서 클릭-확장형 그래프 탐색을 지연 없이 제공 |
| **③ 권한·상태 전파 규칙** | • Link 메타에 permissionInheritance, statePropagation 플래그 정의• OMS가 액션·워크플로 서비스에 전달할 정책 딕셔너리 생성 | • “상위 객체 승인 → 하위 객체 자동 승인” 등 업무 규칙을 중앙에서 관리 |
| **④ API 스키마/SDK 생성 포인트** | • GraphQL SDL·OpenAPI 스펙에 링크 기반 필드(orders: [Order])를 자동 내보내기• SingleLink/LinkSet 타입 생성 | • FE·서버리스 함수가 객체 간 관계를 REST/GraphQL에서 즉시 사용 |
⸻

➡ 본 명세를 기준으로 한 치의 변형 없이 설계·개발·테스트를 수행해야 하며,

➡ 모든 추가 기능·변경은 본 문서 개정 후에만 허용됩니다.